import sys
import gc
# 小整数对象池
# 整数在程序运行过程中使用非常广泛，python为了优化速度，使用了小整数对象池，避免为整数频繁申请和销毁内存空间
# python中对小整数的定义是[-5,257),这些整数对象是提前建立好的，不会被垃圾回收，
# 如下，a和b地址相同
a = 10
b = 10
print(id(a))
print(id(b))

# 大整数对象池
# 每一个大整数，均创建一个新的对象

# intern机制
# a1到a5的地址都相同，这就是intern机制
a1 = 'hello world'
a2 = 'hello world'
a3 = 'hello world'
a4 = 'hello world'
a5 = 'hello world'
print(id(a1))
print(id(a2))
print(id(a3))
print(id(a4))
print(id(a5))

# 数值、字符串、元组都是不可变类型，这意味着无法修改这些变量的值
# 每次对这些变量的修改实际上是创建了一个新的变量

# python垃圾回收的方式
# 引用计数为主，标记-清除和分代收集为辅

# 引用计数
# 引用计数法的原理是：每个对象维护一个ob_ref字段，用来记录该对象当前被引用的次数，每当新的引用指向该对象时，它的引用计数ob_ref加1，每当
# 该对象的引用失效时计数ob_ref减1，一旦对象的引用计数为0，该对象立即被回收，对象占用的内存空间将被释放
# 引用计数的优点：简单、实时（一旦没有引用，内存就直接释放了）
# 引用计数的缺点：维护引用计数消耗资源，无法检测循环引用（因此会引起内存泄漏）
################################################
# 导致引用计数+1的情况
# 对象被创建，例如a=23
# 对象被引用，例如b=a
# 对象被作为参数，传入到一个函数中，例如func(a)
# 对象作为一个元素，存储在容器中，例如list1=[a,a]
################################################
# 导致引用计数-1的情况
# 对象的别名被显式销毁，例如del a
# 对象的别名被赋予新的对象，例如a=24
# 一个对象离开它的作用域，例如f函数执行完毕时，func函数中的局部变量（全局变量不会）
# 对象所在的容器被销毁，或从容器中删除对象

# 标记-清除
# 标记清除做了两项工作，第一项是标记，第二项是清除
# 标记：标记的过程其实就是，遍历所有的GC Roots，然后将所有GC Roots可达的对象标记为存活的对象
# 清除：清除的过程将遍历堆中所有的对象，将没有标记的对象全部清除掉
# 标记-清除也有缺点，即每次都要扫描整个堆内存，效率不高

# 分代回收
# 分为新生代（第1代）、中年代（第2代）、老年代（第3代），它们对应的是三个链表
# 垃圾处理器会更频繁的处理新对象
# 新创建的对象会首先分配到新生代，当新生代链表中总数达到上限时，就会触发python的垃圾回收机制，把那些可以回收的对象回收掉，回收不掉的对象就会移动到中年代，以此类推，老年代的对象是存活时间最久的对象，甚至是存活于整个系统的生命周期内
# 这种算法的根源来自于弱代假说(weak generational hypothesis)。这个假说由两个观点构成：首先是年青的对象通常死得也快
# 而老对象则很有可能存活更长的时间
# 分代回收是建立在标记清除技术之上的

# 三种情况会触发垃圾回收
# 1.当调用gc.collect时
# 2.当gc模块的计数器达到阈值的时候
# 3.程序退出的时候
# gc阈值--被分配对象的计数值与被释放对象的计数值之间的差值

# 查看一个对象的引用计数
mm = 'what a fuck'
print(sys.getrefcount(mm))


# 设置gc的debug日志,一般设置为gc.DEBUG_LEAK,此日志会打印在终端窗口
# gc.set_debug(gc.DEBUG_LEAK)

# 显式进行垃圾回收，可以输入参数，0代表只检查第一代的对象，1代表检查一、二代的对象，2代表检查一、二、三代的对象，不传参数相当于传2，也就是全检查
# 返回值为不可达对象的数目
gc.collect()

# 获得gc模块中自动进行垃圾回收的阈值，得到的是一个有3个元素的元组，分别代表一、二、三代的阈值
print(gc.get_threshold())

# 设置gc模块进行垃圾回收的阈值,gc.set_threshold(threshold0[, threshold1[, threshold2])
gc.set_threshold(700, 10, 10)

# gc.get_count()获取当前用于垃圾回收的计数器,返回值同样是3个元素的元组，这三个元素与各自阈值进行比较，当大于阈值时，执行对应代数的垃圾检查回收操作，然后重置计数器
print(gc.get_count())

# gc模块唯一处理不了的是循环引用的类中含有__del()__方法，所以项目中还是避免定义__del()__方法
